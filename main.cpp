/**
Задача №4
Создать абстрактный базовый класс фигура, поддерживающий чисто виртуальные методы
1) "площадь" и "периметр"
2) "печать" (отправка на ostream) - защищенный
3*) операцию присваивания из ссылки на другую фигуру

Реализовать перегрузку операции << для фигуры.

Создать производные классы "окружность", "прямоугольник", "эллипс" и др.
(по желанию), реализующие конструкторы по необходимым значениям параметров, определяющих фигуру,
и конкретизацию необходимых абстрактных методов базового класса (*операцию присваивания из абстрактной фигуры
реализовать путем динамического приведения типа к конкретной фигуре).

Вопросы: Наследование, полиморфизм, операция присваивания из ссылки на другую фигуру.


Задача №5* (сложная, но интересная - рекомендую)

Реализовать абстрактный базовый класс "фигура", характеризующийся

1) координатами опорной точки (x, y) - центр окружности, угол квадрата и т.п., по своему усмотрению;
2) массивом параметров фигуры (лучше использовать std::vector) - размер массива определяется конструктором и задается конкретной фигурой (например, радиус, сторона и т.д.);
3) массивом строковых имен названий параметров (размер также определяется конструктором, но значения заполняется конструктором конкретных классов);
4) состоянием - показана фигура в данный момент или нет;
(конструктор должен иметь два аргумента - количество параметров фигуры, и начальное состояние, по умолчанию - не показана)

и имеющий методы
1) show и hide - отображения (отрисовка цветом) и стирания (отрисовка фоном) с помощью графической библиотеки (openbgi или другой, поддерживающей поточечное рисование фигур) -
в базовом классе только изменяет состояние фигуры и вызывает соответствующий виртуальный метод конкретного класса, а также метод получения состояния;

2) получения и изменения опорной точки - т.е. перемещения фигуры, причем если фигура отображается, сеттер должен стереть и нарисовать ее на новом месте;

3) получения количества параметров

4) получение и изменения значения параметра по номеру (для получения можно использовать operator [],
но для изменения нужен полноценный сеттер, который сотрет старую и нарисует новую фигуру на новом месте), если номер вне диапазона метод должен бросать исключение;

5) получения строкового имени параметра фигуры по номеру, если номер вне диапазона метод должен бросать исключение;

6) фактической отрисовки и стирания фигуры (абстрактный, защищенный);

Создать производные классы - конкретные фигуры (окружность, эллипс, квадрат, прямоугольник и другие - на свой выбор).
Классы должны реализовывать методы отрисовки и стирания, а также конструктор, заполняющий строковые имена параметров и их значения.

Программа ведет массив указателей (std::vector<figure*> или связный список фигур std::list<figure*>) на базовый класс "фигура"
(не забываем про виртуальный деструктор!) и графическое окно. Пользовательский интерфейс выводит список имеющихся фигур,
по возможности с указанием отображена она или нет, их положения и параметров, и предлагает

1) Добавить фигуру из списка поддерживаемых фигур, запрашивая координаты и параметры по их строковым именам;

2) Изменить положение фигуры по номеру фигуры;

3) Изменить параметр фигуры по номеру фигуры и имени параметра (вводить лучше номер, но программа должна вывести список имен параметров с номерами);

4) Удалить фигуру по номеру фигуры.

Подумайте, как можно улучшить программу.

1) Кроме положения добавить угол поворота фигуры.

2) Давать фигурам собственные имена и позволять пользователю идентифицировать фигуру по имени, вести список фигур через std::map<std::string, figure*>.

3) Добавить перемещение (и поворот) стрелками, а не вводом координат.

4) Добавить цвет фигуры.

И т.д

Вопросы: методы отрисовки, стирания, Openbgi, реализация некоторых методов.

Задача №6
Создать абстрактный базовый класс "односвязный список" ((a) - целых чисел, (б) - шаблонный), имеющий абстрактные методы
1) Push
2) Pop
3) GetFront
4) IsEmpty
5) Size
6) Print (защищенный)

7) Операцию присваивания из ссылки на "список"
и внутренний тип node (защищенный), реализовать перегрузку операции вывода (<< - через Print) и ввода (>> - через Push).


Реализовать конкретные классы Стек и Очередь, имеющие необходимые конструкторы пустого списка, копирования, перемещения,
операции присваивания и присваивания по перемещению из ссылки на себя *и ссылки на фигуру
(копирование должно работать за O(1) и один проход списка, IsEmpty - за O(1)), реализацию абстрактных методов.
*/

#include<iostream>
#include"Figures.h"
#include"List.h"
#include"Queue.h"
#include"Stack.h"
using namespace std;


int main()
{
//    queue<double> Q;
//    cin >> Q;
//    cout << Q;
//    queue<double> _Q = Q;
//    cout << _Q;
//    cin >> Q;
//    cout << Q;
//    cout << _Q;
//
//    stack<double> S;
//    cin >> S >> S >> S >> S >> S;
//    cout << S;
//    stack<double> _S = S;
//    cout << _S;


//    rectangle<double> A (12,20);
//    rectangle<double> B = A;
//    circle<double> C (5);
//    circle<double> D = C;
//    ellipse<double> E (13, 5);
//    ellipse<double> F = E;
//    cout << A;
//    cout << B;
//    cout << C;
//    cout << D;
//    cout << E;
//    cout << F;

    size_t p;
    cout << "Press 1 to pick the queue or 2 to pick the stack: ";
    cin >> p;
    double key;
    size_t id;

    if(p == 1)
    {
//        size_t k;
//        cout << "Press 1 for double-type queue, 2 for int-type queue";
//        cin >> k;
//        switch(k)
//        {
//        case 1:
//            queue<double> q;
//            break;
//
//        }
        queue<double> q;


        size_t p;
        cout << "Choose the method:\n1. Push\n2. PopFront\n3. GetFront\n4. SetFront\n5. IsEmpty\n6. QuantifyQueue\n7. Print queue's element\n8. PrintQueue\n\n";
        cin >> p;
        while(1 <= p && p <= 8)
        {
            switch(p)
            {
            case 1:
                cout << "Enter the number (0 to return): ";
                cin >> key;
                while(key)
                {
                    q.Push(key);
                    cout << q;
                    cin >> key;
                }
                break;
            case 2:
                cout << "Pop: " << q.Pop();
                break;
            case 3:
                key = q.GetFront();
                cout << "Get: " << key;
                break;
            case 4:
                break;
            case 5:
                cout << "Is Empty: " << q.IsEmpty();
                break;
            case 6:
                cout << "Current amount: " << q.Size();
                cout << q;
                break;
            case 7:
                cout << "Enter the number: ";
                cin >> id;
                cout << q[id];
                break;
            case 8:
                cout << q;
                break;
            default:
                break;
            }
            cout << "\nChoose the method:\n1. Push\n2. PopFront\n3. GetFront\n4. SetFront\n5. IsEmpty\n6. QuantifyQueue\n7. Print queue's element\n8. PrintQueue\n\n";
            cin >> p;
        }
        queue<double> q2 = q;
        cout << q2;
    }
    else if(p == 2)
    {
        stack<double> s;


        size_t p;
        cout << "Choose the method:\n1. Push\n2. PopFront\n3. GetFront\n4. SetFront\n5. IsEmpty\n6. QuantifyStack\n7. Print stack's element\n8. PrintStack\n\n";
        cin >> p;
        while(1 <= p && p <= 9)
        {
            switch(p)
            {
            case 1:
                cout << "Enter the number (0 to return): ";
                cin >> key;
                while(key)
                {
                    s.Push(key);
                    cout << s;
                    cin >> key;
                }
                break;
            case 2:
                cout << "Pop: " << s.Pop();
                break;
            case 3:
                key = s.GetFront();
                cout << "Get: " << key;
                break;
            case 4:
                break;
            case 5:
                cout << "Is Empty: " << s.IsEmpty();
                break;
            case 6:
                cout << "Current amount: " << s.Size();
                cout << s;
                break;
            case 7:
                cout << "Enter the number: ";
                cin >> id;
                cout << s[id];
                break;
            case 8:
                cout << s;
            default:
                break;
            }
            cout << "\nChoose the method:\n1. Push\n2. PopFront\n3. GetFront\n4. SetFront\n5. IsEmpty\n6. QuantifyStack\n7. Print stack's element\n8. PrintStack\n\n";
            cin >> p;
        }
        stack<double> s2 = s;
        cout << s2;
    } else {cout << "Wrong number. Finishing programme...";}
    cout << "\n... Memory cleared";
    return 0;
}
